---
# The k3s project has taken the unusual decision to host built
# binaries without any wrapper or compression at all. You just
# download the actual binary and away you go. This is possible
# since Go binaries famously have no dependencies.

# This made me feel slimy and naked so I wrapped it up in a
# tarball. It didn't even have a version number attached.

# TODO: meta this? The whole 'download and tar' section is heavily distro-dependent.

- name: 'Ensure directory exists'
  connection: 'local'
  run_once: yes
  become: no
  file:
    path: '{{ k3s_binaries_dir }}'
    state: 'directory'

- name: 'Check if tarball exists already'
  register: 'reg_tarball'
  connection: 'local'
  run_once: yes
  become: no
  stat:
    path: '{{ k3s_tarball }}'

- name: 'Get checksum from tarballed file'
  when: 'reg_tarball.stat.exists'
  register: 'reg_checksum'
  connection: 'local'
  run_once: yes
  become: no
  archived_checksum:
    path: '{{ k3s_tarball }}'
    archived_file: 'k3s'

- name: 'Download specified binaries'
  when: 'file_checksum != k3s_sha256_checksum
         or not reg_tarball.stat.exists'
  connection: 'local'
  become: no
  run_once: yes
  vars:
    file_checksum: '{{ (reg_checksum.stdout_lines | first).split(" ")[0] }}'
  loop: '{{ k3s_downloads }}'
  loop_control:
    label: '{{ item.url | basename }}'
  get_url:
    url: '{{ item.url }}'
    dest: '{{ k3s_binaries_dir }}/'
    checksum: '{{ item.checksum }}'

# TODO: changed_when
- name: 'Tarball up binaries'
  when: 'file_checksum != k3s_sha256_checksum
         or not reg_tarball.stat.exists'
  connection: 'local'
  become: no
  run_once: yes
  vars:
    file: '{{ k3s_binaries_dir }}/{{ item.url | basename }}'
    file_checksum: '{{ (reg_checksum.stdout_lines | first).split(" ")[0] }}'
  loop: '{{ k3s_downloads }}'
  loop_control:
    label: '{{ item.url | basename }}'
  # Module doesn't work due to a bug.
  # archive:
  #   path: '{{ file }}'
  #   dest: '{{ file }}-{{ k3s_version }}.tgz'
  #   format: 'gz'
  #   force_archive: yes
  #   remove: yes
  command:
    argv:
      - 'tar'
      - 'cpzf'
      - '{{ file }}-{{ k3s_version }}.tgz'
      - '-C'
      - '{{ file | dirname }}'
      - '{{ file | basename }}'

- name: 'Unarchive the k3s binary'
  unarchive:
    src: '{{ k3s_tarball }}'
    dest: '{{ k3s_destdir }}/'

- name: 'Permission the binary'
  file:
    path: '{{ k3s_destdir }}/k3s'
    mode: '0755'
    owner: 'root'
    group: 'root'

- name: 'Add shell to /etc/shells'
  loop: '{{ k3s_shells}}'
  lineinfile:
    path: '/etc/shells'
    line: '{{ item }}'
    insertafter: 'EOF'

# TODO: figure out failed_when for chsh
- name: 'Change ansible user shell'
  command:
    argv:
      - '{{ k3s_chsh }}'
      - '-s'
      - '{{ k3s_shells | first }}'
      - 'ansible'

- name: 'Write tmux config'
  loop:
    - '/home/ansible/.tmux.conf'
  template:
    src: '{{ item[1:] }}.j2'
    dest: '{{ item }}'
    owner: 'ansible'
    group: 'ansible'
    mode: '0644'

- name: 'Create logrotate directory'
  file:
    path: '/etc/logrotate.d'
    state: 'directory'

- name: 'Template in logrotate config'
  loop: '{{ k3s_logrotate_configs }}'
  template:
    src: '{{ item[1:] }}.j2'
    dest: '{{ item }}'
    mode: '0644'

- name: 'Set cron job for logrotate'
  cron_legacy:
    name: 'Logrotate'
    cron_file: '/etc/crontab'
    user: 'root'
    job: '/usr/bin/logrotate /etc/logrotate.conf'
    minute: '04'

#    for XTABLES in iptables ip6tables; do
#        if has_working_xtables ${XTABLES}; then
#            $SUDO ${XTABLES}-save 2>/dev/null | grep -v KUBE- | grep -iv flannel | grep -iv cali | $SUDO ${XTABLES}-restore
#        fi
#    done

- name: 'Disable SELinux'
  register: 'reg_selinux'
  failed_when:
    - 'reg_selinux.rc != 0'
    - 'e_selinux_notexists not in reg_selinux.msg'
  replace:
    path: '/etc/selinux/config'
    regexp: '^SELINUX=enforcing$'
    replace: 'SELINUX=disabled'

- name: 'Disable swap'
  replace:
    path: '/etc/fstab'
    regexp: '^([^#].*?\sswap\s+sw\s+.*)$'
    replace: '# \1'
...
# vim: set filetype=yaml
